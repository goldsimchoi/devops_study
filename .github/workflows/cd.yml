name: CD - Build & Push to Docker Hub

# main 브랜치에 push 혹은 태그 생성 시 동작
on:
  push:
    branches: [ main ]
    # 태그(push)를 이용해 버전 릴리스할 수도 있습니다
    tags: [ 'v*.*.*' ]

jobs:
  build-and-push:
    runs-on: ubuntu-latest

    steps:
      # 1) 코드 체크아웃
      - name: Check out code
        uses: actions/checkout@v3

      # 2) Docker Hub 로그인
      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # 3) 이미지 빌드 & 태그 & 푸시
      - name: Build and push Docker image
        uses: docker/build-push-action@v3
        with:
          context: ./apps/backend
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/myflask:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/myflask:${{ github.sha }}

      # 4) 정리(선택)
      - name: Log out from Docker Hub
        run: docker logout

  # Deploy 전에 보안 스캔을 통과해야만 다음 단계로 진행되도록 하는 게이트 job
  security-gate:
    needs: build-and-push
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Check out code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Gitleaks (secrets scan)
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Log in to Docker Hub (for image scan)
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Trivy image scan (CRITICAL)
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: image
          image-ref: ${{ secrets.DOCKERHUB_USERNAME }}/myflask:${{ github.sha }}
          ignore-unfixed: true
          severity: CRITICAL
          exit-code: "1"
          format: table

  deploy:
    needs: security-gate
    runs-on: ubuntu-latest
    env:
      DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME || vars.DOCKERHUB_USERNAME }}
      REMOTE_APP_DIR: ${{ secrets.REMOTE_APP_DIR || vars.REMOTE_APP_DIR }}
      DOMAIN_NAME: ${{ secrets.DOMAIN || vars.DOMAIN }}
      LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL || vars.LETSENCRYPT_EMAIL }}

    steps:
      - uses: actions/checkout@v3

      - name: Prepare SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.GCP_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.GCP_HOST }} >> ~/.ssh/known_hosts

      - name: Ensure remote dir exists
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} "\
            mkdir -p ${REMOTE_APP_DIR}"

      - name: Copy files to VM (scp)
        run: |
          scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -r \
            docker-compose.prod.yml nginx certbot \
            ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }}:${REMOTE_APP_DIR}/

      - name: Validate TLS inputs
        run: |
          [ -n "${REMOTE_APP_DIR}" ] || { echo "REMOTE_APP_DIR is required (set secret or variable)."; exit 1; }
          [ -n "${DOMAIN_NAME}" ] || { echo "DOMAIN_NAME is required (set secret or variable)."; exit 1; }
          [ -n "${LETSENCRYPT_EMAIL}" ] || { echo "LETSENCRYPT_EMAIL is required (set secret or variable)."; exit 1; }

      - name: Issue TLS certificate (first deploy only)
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} "\
            set -euo pipefail; \
            cd ${REMOTE_APP_DIR} && \
            export DOCKERHUB_USERNAME=${DOCKERHUB_USERNAME} && \
            mkdir -p certbot/conf certbot/www && \
            if [ ! -f certbot/conf/live/app/fullchain.pem ]; then \
              docker compose -f docker-compose.prod.yml down || true; \
              docker run --rm -p 80:80 \
                -v ${REMOTE_APP_DIR}/certbot/conf:/etc/letsencrypt \
                -v ${REMOTE_APP_DIR}/certbot/www:/var/www/certbot \
                certbot/certbot certonly --standalone --non-interactive --agree-tos \
                --email ${LETSENCRYPT_EMAIL} --cert-name app \
                -d ${DOMAIN_NAME} -d www.${DOMAIN_NAME}; \
            fi"

      - name: Pull & restart on VM
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.GCP_USER }}@${{ secrets.GCP_HOST }} "\
            set -euo pipefail; \
            cd ${REMOTE_APP_DIR} && \
            export DOCKERHUB_USERNAME=${DOCKERHUB_USERNAME} && \
            docker compose -f docker-compose.prod.yml pull && \
            docker compose -f docker-compose.prod.yml up -d --remove-orphans && \
            docker run --rm \
              -v ${REMOTE_APP_DIR}/certbot/conf:/etc/letsencrypt \
              -v ${REMOTE_APP_DIR}/certbot/www:/var/www/certbot \
              certbot/certbot renew --webroot -w /var/www/certbot --quiet || true; \
            docker compose -f docker-compose.prod.yml exec -T nginx nginx -s reload || true"
